package dbops

import (
	"context"
	"database/sql"
	"fmt"
	"os"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
)

/*
	fmt.Printf("Hey Manuel, this program will:\n")
	fmt.Printf("  * check if inverter is enrolled\n")
	fmt.Printf("  * delete record if it is\n")
	fmt.Printf("  * check if inverter exists\n")
	fmt.Printf("  * delete record if it does\n")
	fmt.Printf("  * double check both records have been deleted from db\n")
	fmt.Printf("  * check if inverter exists on AWS DynamoDB cache\n")
	fmt.Printf("  * delete record if it does\n\n\n")
*/

// CheckIfInverterEnrolled checks if the inverter record exists in the enrollment table.
func (i *Inverter) CheckIfExists(db *sql.DB, sqlTable string) bool{

	// Init sql query
	sqlQuery := fmt.Sprintf("SELECT COUNT(*) FROM %s WHERE macAddress = ?", sqlTable)
	
	// Rows is the result of a query. Its cursor starts before the first row
	// of the result set. Use [Rows.Next] to advance from row to row.
	// Struct built in the database/sql package.
	var count int

	// QueryRow returns a result set that is scannable.
	err := db.QueryRow(sqlQuery, i.MAC).Scan(&count)
	if err != nil {
		fmt.Printf("Query error.\n %v", err)
		return false
	}

	return count > 0
}

// DeleteFromEnrollmentTable delets current inverter mac address record from given sql table.
// TODO: maybe have some general functions to use.
func (i *Inverter) DeleteMacFromTable(db *sql.DB, sqlTable string) error {

	sqlQuery := fmt.Sprintf("DELETE FROM %s WHERE macAddress = ?", sqlTable)

	// db.Exec() executes the query without returning a result set.
	// It returns a Result and an error.

	// A Result summarizes an executed SQL command.
	/*
		type Result interface {
			// LastInsertId returns the integer generated by the database
			// in response to a command. Typically this will be from an
			// "auto increment" column when inserting a new row. Not all
			// databases support this feature, and the syntax of such
			// statements varies.
			LastInsertId() (int64, error)

			// RowsAffected returns the number of rows affected by an
			// update, insert, or delete. Not every database or database
			// driver may support this.
			RowsAffected() (int64, error)
		}
	*/
	result, err := db.Exec(sqlQuery, i.MAC)
	if err != nil {
		return fmt.Errorf("\ndelete error from enrollment table: %v", err)
	}

	// Check how many records have been deleted, should be 1 only.
	resultRowsAffected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("\nrows affected error: %v", err)
	}

	// Is this an error?
	if resultRowsAffected == 0 {
		return fmt.Errorf("\nno record deleted from enrollment table with mac: %s", i.MAC)
	}

	return nil
}

// DeleteFromDynamoDBTable deletes the inverter MAC Address from the given table on AWS DynamoDB.
func (i *Inverter) DeleteMacFromDynamoDBTable(ctx context.Context, client *dynamodb.Client, tableName string) error{

	// Create the input key to be deleted.
	input := &dynamodb.DeleteItemInput{
		TableName:aws.String(tableName),
		Key: map[string]types.AttributeValue{
			// An attribute of type String. For example:
			//
			//	"S": "Hello"
			"macAddress": &types.AttributeValueMemberS{Value: i.MAC},
		},
	}

	// Execute delete operation.
	_, err := client.DeleteItem(ctx, input)
	if err != nil {
		return fmt.Errorf("failed to delete item from AWS DynamoDB table %s. Here's why: %v", tableName, err)
	}

	return nil
}

func InitDynamoClient() *dynamodb.Client {
	cfg, err := config.LoadDefaultConfig(context.TODO())
	if err != nil {
		fmt.Printf("\ncould not download aws configs. Here's why: %v", err)
		time.Sleep(3*time.Second)
		os.Exit(1)
	}

	return dynamodb.NewFromConfig(cfg)
}
